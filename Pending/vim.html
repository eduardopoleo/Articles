<p>I've been wanting to write this article for a while but it has been hard to find something useful to say about vim that has not been said before, or that does not involve pasting a 300 commands long cheat-sheet. So I decided to write about my journey into vim and also briefly introduce the tools that make my editing tasks more enjoyable.</p>

<h3 style='padding-top:15px;'><i>vimtutor</i></h3>
<p>Like everyone else I started my vim journey using the vimtutor. Vimtutor introduces you to the most fundamental vim concepts and commands. After the first time I went through the tutor I could not even remember half of the commands. But when I came back to it later I realized that it actually taught me (or attempted to) 90% of the commands that I currently use on a daily basis. The tutor also showed me some conceptual and practical stuff, such as:</p>

<ul>
  <li>Vim modes and how to effectively edit a documents by switching among them.</li>
  <li>The concept of OPERATOR + NUMBER + MOTION to concatenate commands and speed up your editing.</li>
  <li>The use of the command mode.</li>
  <li>The use of the .vimrc file for customization.</li>
</ul>

<h3 style='padding-top:15px;'><i>Plugins</i></h3>
I initially started looking into vims plugins because I needed a tool to easily navigate through the rails project directory. But soon after, I discovered many other powerful plugins with diverse functionalities. Before digging into the plugins let's take a look at how to install them.    

<h4><a href="https://github.com/tpope/vim-pathogen" target="_blank">vim-pathogen</a></h4>
<p>Like everything in Vim there are several ways to do this, although from what I have seen repos owners tent to recommend using one of these two plugin managers: vim-pathogen and <a href="https://github.com/gmarik/Vundle.vim" target="_blank">Vundle.vim</a>. I settled for vim-pathogen for no particular reason (probably because it was the first one I came across with). It has worked great so far so I haven't had the need to switch.</p>

<p>Pathogen was developed by Tim Pope, if you plan on using vim for rails development you will hear his name a lot, like a lot lot. Vim-pathogen makes plugins management really convenient. To install a plugin all you have to do is to clone the plugin's repo into your ~/.vim/bundle directory. Conversely, if you want to uninstall a plugin you just have to remove the corresponding plugin folder, and that's it.</p>

<h4><a href="https://github.com/scrooloose/nerdtree" target="_blank">NERDTree</a></h4>
<p>NERDTree was probably the first plugin I installed. It is triggered by typing <code>:NERDtree</code> on the command bar and it displays a project navigation panel on the left side of the editor window (much like Sublime's files directory). The plugin allows you to easily navigate through the current project directory, add, remove and rename documents. It can also open files on splits.</p>

<h4><a href="https://github.com/kien/ctrlp.vim" target="_blank">ctrlp</a></h4>
<p>Not surprisingly, ctrlp is triggered by pressing Ctr+P (or &lt;c-p&gt; in vim's notation) when in normal mode. You then type the file name followed by the return key and the file will be open in your current working panel. The plugin also offers some suggestions as you type. By default the file you are opening will replace the file you are currently working on but there are some commands that allow you to open new files on vertical or horizontal splits.</p>

<h4><a href="https://github.com/tpope/vim-rails" target="_blank">vim-rails</a></h4>
<p>Vim-rails is a very powerful plugin that among other things offers easy navigation through the rails directory. You can easily open up a file just by typing <code>:Rfile_type key_word</code>. For instance, if you want to work on your user model or controller all you have to do is to type <code>:Rmodel user</code> or <code>:Rcontroller users</code> respectively, followed by the return key. This also applies to specs, migrations, mailers, layouts, views actually everything.</p>   

<p>Vim-rails also allows you to quickly generate files and then run them from within the editor itself! which is pretty cool. For instance a common work-flow for me is to generate a migration by:  <code>:Rgenerate migration create_users</code> then <code>:Rmigrations create_users</code> to bring it to my current panel,  write a bit of code and finally <code>:Rake</code>. The <code>:Rake</code> command will run the migration from within the editor itself!. You can also use <code>:Rake</code>to run test, see your routes etc. Vim-rails offers a lot of other functionalities but these are the ones I use most frequently. </p>

<h4 style='padding-top:15px; font-weight: bold;'><a href="https://github.com/tpope/vim-endwise" target="_blank">vim-endwise</a></h4>

<p>This plugin basically autocompletes the end statements of loops, blocks, if, etc. In order to trigger it all you have to do is to hit enter after the structure declaration. It also keeps the corresponding indentation level as it should be.</p>

<h4 style='padding-top:15px; font-weight: bold;'><a href="https://github.com/tomtom/tcomment_vim" target="_blank">tcomment_vim</a></h4>
<p>This plugin allows you to toggle on/off blocks of comments. I do not remember which the default trigger was but right now I have it set up with ctr-/ just like I had it with sublime.</p>

<h4 style='padding-top:15px; font-weight: bold;'><a href="https://github.com/Valloric/YouCompleteMe" target="_blank">YouCompleteMe</a></h4>
<p>YouCompleteMe is a great plugin that displays autocomplete suggestions as you type. This is specially useful when you have long-named variables that repeat over and over. You can scroll through the suggested options by hitting the tab key. The plugin works really fast and it does not hinder your editing area.</p>

<h4 style='padding-top:15px; font-weight: bold;'><a href="https://github.com/SirVer/ultisnips" target="_blank">ultisnips</a></h4>
<p>I found that the most popular plugins for managing snipets were <a href="https://github.com/garbas/vim-snipmate" target="_blank">vim-snipmate</a> and ultisnips. I have tried both and found ultisnips far superior for many reasons: </p>

<ul>
  <li>First of all it has a really nice documentation that includes introductory videos to get you started.</li>
  <li>Contrary to vim-snipmate, ultisnips is very good with snippets that are sensible to indentation (e.g haml). What ever you wrote on the snip will come out as it is, no weird extra spaces added.</li>
  <li>Ultisnips with all its functionalities comes as a standalone plugin and it does not have you installing 2 other plugins in order for it to work (as it happens with snipmate).</li>
  <li>Last but not least, the creators of ultisnips and YouCompleteMe collaborated and now you also get snippets suggestions from the YouCompleteMe pop-up which is awesome!</li>
</ul>

<h4 style='padding-top:15px; font-weight: bold;'><a href="https://github.com/thoughtbot/vim-rspec" target="_blank">vim-rspec</a></h4>

<p>Vim-spec is the latest addition to my plugin repertoire. This plugin allows you to easily run the specs from within the editor. As I mentioned before you can also do that by using vim-rails <code>:Rake</code> but this plugin gives you more flexibility. You can set different commands to run the spec you are currently working on, all the specs on your current file, the last spec you ran, or simply run the whole test suite.</p>

<h3 style='padding-top:15px;'><i>.vimrc</i></h3>

<p>After installing all these plugins my vim setup had pretty much solved all my editing needs. Nevertheless, it became really apparent that some of these plugins had really annoying triggers (e.g NERDtree). Additionally, some default triggers even overlapped with each other (ultisnips & YouCompleteMe). That's when I discovered the .vimrc file.</p>

<p>The .vimrc is vim's configuration file and usually lives in your home directory. Within the .vimrc you can set abbreviations, map commands to specific key combinations and set some default options. For instance, I solved the specific NERDTree problem by adding <code>ca tr NERDTree</code>. After this instead of having to type the full <code>:NERDTree</code> on the command bar I only had to type <code>:tr</code> and press the return key. Other good example was <code>map &lt;Space&gt;s :call RunNearestSpec()<CR></code> which allows me to run the current spec just by pressing "space" and "s".</p>

<p>When I discovered the power of the .vimrc I immediately started overriding lots of vim's defaults in order to make it more "personalized". But the more I <a href="https://pragprog.com/book/dnvim/practical-vim" target="_blank">read</a> and learned, the more I found myself going back to the "factory settings". Nonetheless, if you are reading this and you are still planning to get started with vim I highly encourage you to experiment like I did. This will allow you to better understand why things were initially put in a certain way.</p>

<h3 style='padding-top:15px;'><i>Where I'm at right now.</i></h3>
<p>Right now I feel that I am slightly more productive using vim that I was using other editors for a couple of reasons: I can seamlessly run almost all the commands within my editor, and I have a much better and accurate text selection using the visual mode than using the horrible mouse pad on my laptop. But I still feel that I'm miles away from unleashing the true power of vim. As an example, I haven't really started using the <code>.</code> and the <code>*</code> as much as I know I should, and I have not got around using macros yet. But the fact that vim has become my main editor for all purposes (rails, blogging) and that I do not have to switch back to sublime still feels like an accomplishment. </p>

<p>Another curious thing is that since I started using vim I have probably spent around 15+ hrs fiddling around learning and improving my development environment. This is kind of crazy considering how little time it takes to get started with other editors and IDEs, but I am sure all this effort will pay back sooner than later. On my next article I'm going to talk about Tmux!, I'm already excited :).</p>

<p> This is my longest article yet! I really appreciate that you made it this far! Happy coding.</p>
